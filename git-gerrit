#!/bin/bash
# git-gerrit - download, use, and review gerrit patches
#
# compatible with git-review configuration files
#
# Copyright 2015 Kylie McClain <somasissounds@gmail.com>
# Distributed under the terms of the ISC license

# initialization
# functions
stderr() { # stderr <msg>
    echo "$@" >&2
}

debug() { # debug [msg]
    if [[ -z "$debug" ]];then
        return 1 # debug not set
    elif [[ ! -z "$debug" && "$#" -gt 0 ]];then
        stderr "$@"
    else
        return 0
    fi
}

die() { # die <err msg> <err code> or die <err code>
    if [[ "$#" -gt 1 ]];then
        local err_msg="$1"
        local err_code="$2"
        stderr "$me: $err_msg; dying"
        exit "$err_code"
    else
        local err_code="$1"
        exit "$err_code"
    fi
}

in_git_dir() {
    if ! git rev-parse --git-dir >/dev/null 2>&1;then
        return 1
    fi
}

git() {
    debug "$me: executing \`git $*\`"
    command git "$@"
}

config() {
    if [[ "$1" == "list" ]];then
        git config --list
    elif [[ "$1" == "exist" ]];then
        shift
        local var="$1"
        if git config --get "$var" >/dev/null 2>&1;then
            return 0 # does exist in config
        else
            return 1 # doesn't
        fi
    elif [[ "$1" == "set" ]];then
        shift
        local var="$1"
        local value="$2"
        [[ -z "$value" ]] && local mode='--unset'
        git config $mode "$var" "$value"
    elif [[ "$1" == 'get' ]];then
        shift
        local var="$1"
        git config --get "$var"
    fi
}

nonfatal() {
    nonfatal=true
    eval "$@"
    nonfatal=
}

dossh() {
    debug "$me: executing \`ssh -o ConnectTimeout=30 -x -p \"${gerrit_port}\" \"${gerrit_username}@${gerrit_host}\" \"$@\"\`"
    ssh -o ConnectTimeout=30 -x -p "${gerrit_port}" "${gerrit_username}@${gerrit_host}" "$@" || { [[ "$nonfatal" ]] || die "dossh failed" 6; }
}

parse_config() {
    gitreview="${work_dir}/.gitreview"
    if [[ ! -f "${gitreview}" ]];then
        die "No .gitreview config in top of work directory" $err_no_gitreview
    fi

    gerrit_host=$(grep '^host=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_project=$(grep '^project=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_port=${gerrit_host##*:}
    if [[ -z "$gerrit_port" || "$gerrit_port" == "$gerrit_host" ]];then
        gerrit_port="29418"
    fi

    if ! config exist remote.gerrit.url;then
        nonfatal dossh >/dev/null 2>&1
        if [[ "$?" -eq 127 ]];then
            debug "Connected to ${gerrit_username}@${gerrit_host}:${gerrit_port} successfully"
            gerrit_url="ssh://${gerrit_username}@${gerrit_host}:${gerrit_port}/${gerrit_project}.git"
        else
            die "SSH connection to ${gerrit_username}@${gerrit_host}:${gerrit_port} failed!" $err_ssh_failed
        fi

        stderr "Adding a remote named \"gerrit\" pointing to \"$gerrit_url\"..."
        git remote add gerrit "${gerrit_url}"
    else
        gerrit_url=$(config get remote.gerrit.url | sed "s#/${gerrit_project}.*##;s#.*://##")
        gerrit_type=$(config get remote.gerrit.url | sed 's#://.*##')
        debug "Gerrit instance: \"$gerrit_url\" (type: $gerrit_type)"
    fi
}

# gerrit operations
gerrit() {
    dossh gerrit "$@"
}

query_patches() {
    if [[ "$#" -lt 1 ]];then
        query="project:${gerrit_project} status:open"
    else
        query="$@"
    fi
    debug "$me: querying ${gerrit_url} for patches matching \"${query}\""
    local json=$(gerrit query --format=JSON "${query}")

    # gerrit always provides more than one line of output, unless there
    # were no query results. so, 1 line = no results
    if [[ $(echo "${json}" | wc -l) -eq 1 ]];then
        die "No results for query \"${query}\"" $err_no_results
    fi

    # let me explain this a little bit:
    # first, we take the json, read it line by line, since gerrit sends a
    # single line of json per change matching the query.
    # then, we use jshon to read the line's number, branch, id, name set
    # inside of the owner object, and then the top level subject of the change.
    # after that's done, we use paste to correctly sequence the lines so
    # that we can just parse it easily with cut.
    #
    # also, jshon doesn't seem to properly decode unicode things! but, it
    # does leave us a u#### string. so, we can try and assume it's a unicode
    # symbol which we need to decode... which is really hacky and needs to
    # be fixed in jshon, probably.
    local parsed=$(
        echo "$json" | \
            while read line;do
                echo "$line" | \
                    jshon -Q    -e number -up           \
                                -e branch -up           \
                                -e id     -up           \
                                -e owner -e name -upp   \
                                -e subject -u
            done | grep -v '^$' | sed 's#u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]#\\&#g' |
        paste -s -d '||||\n'
    )
    echo -e "${parsed[@]}"
}

list_patches() {
    query_patches "$@" | while read line; do
        number=$(echo "$line" | cut -d'|' -f1)
        branch=$(echo "$line" | cut -d'|' -f2)
        change=$(echo "$line" | cut -d'|' -f3)
        author=$(echo "$line" | cut -d'|' -f4)
        subject=$(echo "$line" | cut -d'|' -f5-)
        printf "%s\t%s\t%s\t%s\n" "${number}" "${gerrit_project}:${branch}" "${subject}" "${author}"
    done | sort -n | column -t -s $'\t'
}

get_patches() {
    if [[ "$#" -lt 1 ]];then
        stderr "usage: $name get <patches>"
        die $err_args
    fi

    for patch in $@;do
        number="$1"
        debug "$me: downloading patch #${number}"
        query_patches "project:${gerrit_project}" | cut -d'|' -f1
        #git pull $(debug && echo -v) gerrit re
    done
}

# vars, shopts, etc
export LC_ALL=C # ensure program outputs are predicatble
me="git-gerrit"
name=${me/-/ }

# error codes - don't set any of these 0 or 1, dummy
err_not_git_dir=2
err_bare_repo=3
err_no_gitreview=4
err_no_username=5
err_ssh_failed=6
err_args=7
err_no_results=10
err_prog_not_installed=70

# make sure that the programs we need are there
type -fPp git >/dev/null 2>&1 || die "\`git\` isn't installed!" $err_prog_not_installed
type -fPp jshon >/dev/null 2>&1 || die "\`jshon\` isn't installed!" $err_prog_not_installed

# sanity checks
if ! git rev-parse --git-dir >/dev/null 2>&1;then
    die "Not a git repository" $err_not_git_dir
fi

if config exist gitreview.username;then
    gerrit_username=$(config get gitreview.username)
else
    die "You need to set a username to use; \`git config gitreview.username <username>\`" $err_no_username
fi

if [[ "$(git rev-parse --is-bare-repository)" == 'true' ]];then
    die "Cowardly refusing to operate on a bare repository" $err_bare_repo
fi

export git_dir=$(realpath $(git rev-parse --git-dir))
export work_dir=$(realpath $(git rev-parse --show-toplevel))

parse_config

#stderr "git gitdir: $git_dir"
#stderr "git workdir: $work_dir"
#stderr "gitreview: $gitreview"
#stderr "gerrit username: $gerrit_username"
#stderr "gerrit host: $gerrit_host"
#stderr "gerrit project: $gerrit_project"
#stderr "gerrit url: $gerrit_url"

case "$1" in
    ls)
        #debug "$me: Listing patches for ${gerrit_project}..."
        shift
        list_patches "${@:-project:${gerrit_project} status:open}"
    ;;
    get)
        shift
        get_patches "$@"
    ;;
esac
