#!/bin/bash
# git-gerrit - list, download, and review gerrit patches - version 0.1
# usage: git gerrit [action]
# Interact with a Gerrit server via SSH; list, pull, and create patches.
#
# Reads git-review-style configuration files from the top directory of
# the current git repository.
#
# If no action is given, commits will be pushed for review.
#
# Actions:
#      review|push [branch:<project branch>] [topic:<patch topic>]
#                  [type:<review|draft>]
#           Send all local commits to Gerrit for review.
#
#      get|pull <patches>
#           Download and apply patches from Gerrit.
#
#      -2|-1|0|+1|+2 <patches>
#           Give each patch a corrisponding code review.
#
#      submit|retest <patches>
#           Submit or Retest+1 each patch.
#
#      list|ls [query]
#           List reviews matching <query> on the current project.
#           If no query is given, "status:open" is default query.
#
#      info <patches>
#           Show more in-depth information about each patch given.
#
#      browse <patches>
#           Open the URL to each patch with $BROWSER.
#
#      query <query>
#           Run a raw query on Gerrit and show the results.
#
#      help
#           Show this help message.
#
#      version
#           Print current version and copyright.
#
# End of help.
# Copyright (c) 2015, Kylie McClain <somasissounds@gmail.com>
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# End of copyright.

# initialization
# functions
stderr() { # stderr <msg>
    echo "$@" >&2
}

info() {
    stderr "$@"
}

debug() { # debug [msg]
    if [[ -z "$debug" ]];then
        return 1 # debug not set
    elif [[ ! -z "$debug" && "$#" -gt 0 ]];then
        stderr "$@"
    else
        return 0
    fi
}

die() { # die <err msg> <err code> or die <err code>
    if [[ "$#" -gt 1 ]];then
        local err_msg="$1"
        local err_code="$2"
        stderr "$me: $err_msg; dying"
    else
        local err_code="$1"
    fi
    exit $err_code
}

help() {
    sed -n '/^#/!d;s/^# //;s/^#//;3,${p;}' "$0" | \
        while IFS= read help_line;do
            if [[ "$help_line" == "End of help." ]];then
                exit 0
            else
                printf "%s\n" "$help_line"
            fi
        done
    exit 0
}

version() {
    sed 's/^# //;s/.* - version/'"${0##*/}"'/;2q;$!d' "$0"
    copyright
    exit 0
}

copyright() {
    sed -n '/^#/!d;s/^# //;s/^#//;/End of help./,${p;}' "$0" | \
    while IFS= read copyright_line;do
        if [[ "$copyright_line" == "End of help." ]];then
            true
        elif [[ "$copyright_line" == "End of copyright." ]];then
            break
        else
            printf "%s\n" "$copyright_line"
        fi
    done
}

in_git_dir() {
    if ! git rev-parse --git-dir >/dev/null 2>&1;then
        return 1
    fi
}

git() {
    debug "$me: executing \`git $*\`"
    command git "$@"
}

config() {
    if [[ "$1" == "list" ]];then
        git config --list
    elif [[ "$1" == "exist" ]];then
        shift
        local var="$1"
        if git config --get "$var" >/dev/null 2>&1;then
            return 0 # does exist in config
        else
            return 1 # doesn't
        fi
    elif [[ "$1" == "set" ]];then
        shift
        local var="$1"
        local value="$2"
        [[ -z "$value" ]] && local mode='--unset'
        git config $mode "$var" "$value"
    elif [[ "$1" == 'get' ]];then
        shift
        local var="$1"
        git config --get "$var"
    fi
}

nonfatal() {
    nonfatal=true
    eval "$@"
    nonfatal=
}

dossh() {
    debug "$me: executing \`ssh -o ConnectTimeout=30 -p \"${gerrit_port}\" \"${gerrit_username}@${gerrit_host}\" \"$@\"\`"
    ssh -o ConnectTimeout=30 -p "${gerrit_port}" "${gerrit_username}@${gerrit_host}" "$@" 2>/dev/null; return $?
}

parse_config() {
    gitreview="${work_dir}/.gitreview"
    if [[ ! -f "${gitreview}" ]];then
        die "No .gitreview config in top of work directory" $err_no_gitreview
    fi

    gerrit_host=$(grep '^host=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_project=$(grep '^project=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_port=${gerrit_host##*:}
    if [[ -z "$gerrit_port" || "$gerrit_port" == "$gerrit_host" ]];then
        gerrit_port="29418"
    fi

    if ! config exist remote.gerrit.url;then
        nonfatal dossh gerrit >/dev/null 2>&1
        if [[ "$?" -eq 0 ]];then
            debug "Connected to ${gerrit_username}@${gerrit_host}:${gerrit_port} successfully"
            gerrit_url="ssh://${gerrit_username}@${gerrit_host}:${gerrit_port}/${gerrit_project}.git"
        else
            die "SSH connection to ${gerrit_username}@${gerrit_host}:${gerrit_port} failed" $err_ssh_failed
        fi

        stderr "Adding a remote named \"gerrit\" pointing to \"$gerrit_url\"..."
        git remote add gerrit "${gerrit_url}"
    else
        gerrit_url=$(config get remote.gerrit.url | sed "s#/${gerrit_project}.*##;s#.*://##")
        debug "$me: Gerrit instance: \"$gerrit_url\""
    fi
    if [[ ! -f "${git_dir}/hooks/commit-msg" ]];then
        debug "$me: getting commit-msg hook for Change-Id lines from \"${gerrit_url}\"..."
        if ! scp -p -P  "${gerrit_port}" "${gerrit_username}@${gerrit_host}":hooks/commit-msg\
                        "${git_dir}/hooks/commit-msg" >/dev/null 2>&1;then
            die "Failed to \`scp\` the Change-Id hook" $err_scp_failed
        fi
    fi
}

page() {
    if [[ -z "$@" ]];then
        echo -n "$(</dev/stdin)" | ${GIT_PAGER:-${PAGER:-cat}}
    else
        ${GIT_PAGER:-${PAGER:-cat}} "$@"
    fi
}

# gerrit operations
gerrit() {
    dossh gerrit "$@"
}

query_patches() {
    local query="$@"
    debug "$me: querying ${gerrit_url} for patches matching \"${query}\""

    local json=$(gerrit query --format=JSON --all-approvals --current-patch-set "${query}" | tr -d '\t' | sed "s#\\\\n##g;s#\\\\\"#'#g")

    if [[ $(echo "${json}" | wc -l) -eq 1 ]];then
        [[ "${nonfatal}" ]] || die "No results for query \"${query}\"" $err_no_results
    fi

    # let me explain this a little bit:
    # first, we take the json, read it line by line, since gerrit sends a
    # single line of json per change matching the query.
    # then, we use jshon to read the line's number, branch, id, name set
    # inside of the owner object, and then the top level subject of the change.
    # after that's done, we use paste to correctly sequence the lines so
    # that we can just parse it easily with cut.
    # changenum|patchset|project|branch|changeid|status|url|ref|subject|owner|email|topic
    local parsed=$(
        printf '%s\n' "$json" | \
            while read line;do
                printf '%s' "$line" | \
                    jshon  -Q   -e number -up               \
                                -e currentPatchSet          \
                                        -e number   -upp    \
                                -e project  -up             \
                                -e branch   -up             \
                                -e id       -up             \
                                -e status   -up             \
                                -e url      -up             \
                                -e currentPatchSet          \
                                        -e ref      -upp    \
                                -e subject  -up             \
                                -e currentPatchSet          \
                                        -e author           \
                                        -e name -up         \
                                        -e email -uppp      \
                                -e topic -u                 |
                    tr -d $'\t' | paste -s -d $'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\t'$'\n' | grep -v '^$'
            done | sed 's#u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]#\\&#g'
    )
    echo -e "${parsed[@]}"
}

list_patches() {
    query_patches "$@" | while read line; do
        number=$(echo "$line" | cut -d$'\t' -f1):$(echo "$line" | cut -d$'\t' -f2)
        project=$(echo "$line" | cut -d$'\t' -f3)
        branch=$(echo "$line" | cut -d$'\t' -f4)
        subject=$(echo "$line" | cut -d$'\t' -f9)
        owner=$(echo "$line" | cut -d$'\t' -f10)" <"$(echo "$line" | cut -d$'\t' -f11)">"
        topic=$(echo "$line" | cut -d$'\t' -f12)
        [[ "$topic" ]] && topic=":$topic"
        echo -e "${number}\t${project}/${branch}${topic}\t${subject}\t${owner}"
    done | sort -n | column -t -s $'\t' -o $'\t'
}

push_patch() {
    local change
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    local branch=${current_branch}
    local topic
    local type=review
    for arg in "$@";do
        case "$arg" in
            "type:"*)
                local type=${arg#type:}
            ;;
            "branch:"*)
                local branch=${arg#branch:}
            ;;
            "topic:"*)
                local topic="%topic=${arg#topic:}"
            ;;
            *)
                # default is topic
                local topic="%topic=${arg}"
            ;;
        esac
    done
    debug "$me: Making sure you have the Change-Id on commits for Gerrit..."
    for change in $(git rev-list origin/${branch}..${current_branch});do
        if [[ -z $(git show -s --format=%B "${change}" | grep '^Change-Id: ') ]];then
            change=${change:0:7} # rebase uses short hashes
            debug "$me: Amending ${change} with Change-Id hook"
            OLD_EDITOR="${EDITOR}"
            git stash >/dev/null 2>&1
            export EDITOR="sed -i \"s/^pick ${change} /reword ${change} /\""
            git rebase -i "${change}"^
            git stash pop >/dev/null 2>&1
            export EDITOR="${OLD_EDITOR}"
        fi
    done
    case "$type" in
        review)
            local push="HEAD:refs/for/${branch}${topic}"
        ;;
        draft)
            local push="HEAD:refs/drafts/${branch}${topic}"
        ;;
        *)
            die "Invalid review type: ${type}" $err_invalid_review
        ;;
    esac
    git push gerrit "${push}"
}

info_patches() {
    # changenum|patchset|project|branch|changeid|status|url|ref|subject|owner|email|topic
    for patch in $@;do
        debug "$me: Getting info about #${patch}..."
        query_patches "${patch}" | while read line;do
            number=$(echo "$line" | cut -d$'\t' -f1)
            patchset=$(echo "$line" | cut -d$'\t' -f2)
            project=$(echo "$line" | cut -d$'\t' -f3)
            branch=$(echo "$line" | cut -d$'\t' -f4)
            changeid=$(echo "$line" | cut -d$'\t' -f5)
            status=$(echo "$line" | cut -d$'\t' -f6 | sed 's/.*/\L&/;s/[a-z]*/\u&/g')
            url=$(echo "$line" | cut -d$'\t' -f7)
            ref=$(echo "$line" | cut -d$'\t' -f8)
            subject=$(echo "$line" | cut -d$'\t' -f9)
            owner=$(echo "$line" | cut -d$'\t' -f10)" <"$(echo "$line" | cut -d$'\t' -f11)">"
            topic=$(echo "$line" | cut -d$'\t' -f12)
            echo -e "Change #${patch} for ${project}/${branch}, patchset ${patchset}:"
            echo -e "\tSubject:\t${subject}"
            [[ "$topic" ]] && echo -e "\tTopic:\t\t${topic}"
            echo -e "\tOwner:\t\t${owner}"
            echo
            echo -e "\tStatus:\t\t${status}"
            echo
            echo -e "\tChange-Id:\t${changeid}"
            echo -e "\tURL:\t\t${url}"
            echo -e "\tRef:\t\t${ref}"
            echo
        done
    done
}

get_patches() {
    if [[ "$#" -lt 1 ]];then
        stderr "usage: $name get <patches>"
        die $err_args
    fi

    for patch in $@;do
        debug "$me: downloading patch #${patch}"
        #if patch_exists "${patch}";then
            #blah blah blah write this stuff
        #fi
    done
}

review_patches() {
    action="$1"
    shift
    case "$action" in
        -*|0|+*)
            action="--code-review $action"
            msg="Gave %s a ${action} Code-Review"
        ;;
        submit)
            action="--submit"
            msg="Submitted %s to the project repository"
        ;;
        retest)
            action="--retest +1"
            msg="Set %s to Retest+1"
        ;;
    esac
    for patch in $@;do
        debug "$me: ${action} #${patch}..."
        if patch_exists "$patch";then
            local query=$(query_patches "${patch}")
            patchset=$(echo "${query[@]}" | cut -d$'\t' -f2)
            gerrit review "${patch},${patchset}" $action || die "Failed to run ${action} ${patch},${patchset}" $err_review_failed
            info "$me: $(printf ${msg} ${patch})"
        else
            die "Patch #${patch} does not exist" $err_patch_nonexistent
        fi

    done
}

open_patch_urls() {
    if [[ -z "${BROWSER}" ]];then
        die "You need a browser set as \$BROWSER" $err_no_browser
    fi
    for patch in $@;do
        if patch_exists "$patch";then
            local url=$(query_patches "${patch}" | cut -d$'\t' -f7)
            info "$me: Opening \"${url}\" in \`${BROWSER}\`..."
            ${BROWSER} "$url" & disown
        else
            die "Patch ${patch} does not exist on Gerrit" $err_patch_nonexistent
        fi
    done
}

patch_exists() { # takes input from stdin, expects query_patches output, exits 1 if non-existent
    if [[ "$1" == 'stdin' ]];then
        local input="$(</dev/stdin)"
        shift
    else
        local input=$(nonfatal query_patches "${1}")
    fi
    if echo "$input" | cut -d$'\t' -f1 | grep -q "^${patch}$";then
        debug "$me: Patch #${patch} exists on the Gerrit instance"
        return 0
    else
        debug "$me: Patch #${patch} does not exist on the Gerrit instance"
        return 1
    fi
}

# vars, shopts, etc
me="git-gerrit"
name=${me/-/ }

# error codes - don't set any of these 0 or 1, dummy
err_not_git_dir=2
err_bare_repo=3
err_no_gitreview=4
err_no_username=5
err_ssh_failed=6
err_scp_failed=7
err_args=8
err_patch_nonexistent=9
err_no_results=10
err_invalid_review=11
err_review_failed=12
err_no_browser=13
err_prog_not_installed=70

# make sure that the programs we need are there
type -fPp git >/dev/null 2>&1 || die "\`git\` isn't installed!" $err_prog_not_installed
type -fPp jshon >/dev/null 2>&1 || die "\`jshon\` isn't installed!" $err_prog_not_installed

# special case
if [[ "$1" == "help" || "$1" == "version" ]];then
    $1
fi

# sanity checks
if ! git rev-parse --git-dir >/dev/null 2>&1;then
    die "Not a git repository" $err_not_git_dir
fi

if config exist gitreview.username;then
    gerrit_username=$(config get gitreview.username)
else
    die "You need to set a username to use; \`git config gitreview.username <username>\`" $err_no_username
fi

if [[ "$(git rev-parse --is-bare-repository)" == 'true' ]];then
    die "Cowardly refusing to operate on a bare repository" $err_bare_repo
fi

export git_dir=$(realpath $(git rev-parse --git-dir))
export work_dir=$(realpath $(git rev-parse --show-toplevel))

parse_config

#stderr "git gitdir: $git_dir"
#stderr "git workdir: $work_dir"
#stderr "gitreview: $gitreview"
#stderr "gerrit username: $gerrit_username"
#stderr "gerrit host: $gerrit_host"
#stderr "gerrit project: $gerrit_project"
#stderr "gerrit url: $gerrit_url"

case "$1" in
    ls|list)
        #debug "$me: Listing patches for ${gerrit_project}..."
        shift
        list_patches "project:${gerrit_project} ${@:-status:open}" | page
    ;;
    query)
        shift
        if [[ -z "$@" ]];then
            die "A query is required" $err_args
        fi
        list_patches "$@" | page
    ;;
    info)
        shift
        if [[ -z "$@" ]];then
            die "A patch is required" $err_args
        fi
        info_patches "$@" | page
    ;;
    get|pull)
        shift
        get_patches "$@"
    ;;
    -2|-1|0|+1|+2|submit|retest)
        action="$1"
        shift
        if [[ -z "$@" ]];then
            die "A patch is required" $err_args
        fi
        review_patches "$action" "$@"
    ;;
    browse)
        shift
        if [[ -z "$@" ]];then
            die "A patch is required" $err_args
        fi
        open_patch_urls "$@"
    ;;
    ""|review|push)
        shift
        push_patch "$@"
    ;;
#    url)
        #shift

esac
