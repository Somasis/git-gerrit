#!/bin/bash
# git-gerrit - download, use, and review gerrit patches
#
# compatible with git-review configuration files
#
# Copyright 2015 Kylie McClain <somasissounds@gmail.com>
# Distributed under the terms of the ISC license

# initialization
# functions
stderr() { # stderr <msg>
    echo "$@" >&2
}

debug() { # debug [msg]
    if [[ -z "$debug" ]];then
        return 1 # debug not set
    elif [[ ! -z "$debug" && "$#" -gt 0 ]];then
        stderr "$@"
    else
        return 0
    fi
}

die() { # die <err msg> <err code> or die <err code>
    if [[ "$#" -gt 1 ]];then
        local err_msg="$1"
        local err_code="$2"
        stderr "$me: $err_msg; dying"
    else
        local err_code="$1"
    fi
    exit $err_code
}

in_git_dir() {
    if ! git rev-parse --git-dir >/dev/null 2>&1;then
        return 1
    fi
}

git() {
    debug "$me: executing \`git $*\`"
    command git "$@"
}

config() {
    if [[ "$1" == "list" ]];then
        git config --list
    elif [[ "$1" == "exist" ]];then
        shift
        local var="$1"
        if git config --get "$var" >/dev/null 2>&1;then
            return 0 # does exist in config
        else
            return 1 # doesn't
        fi
    elif [[ "$1" == "set" ]];then
        shift
        local var="$1"
        local value="$2"
        [[ -z "$value" ]] && local mode='--unset'
        git config $mode "$var" "$value"
    elif [[ "$1" == 'get' ]];then
        shift
        local var="$1"
        git config --get "$var"
    fi
}

nonfatal() {
    nonfatal=true
    eval "$@"
    nonfatal=
}

dossh() {
    debug "$me: executing \`ssh -o ConnectTimeout=30 -p \"${gerrit_port}\" \"${gerrit_username}@${gerrit_host}\" \"$@\"\`"
    ssh -o ConnectTimeout=30 -p "${gerrit_port}" "${gerrit_username}@${gerrit_host}" "$@"; return $?
}

parse_config() {
    gitreview="${work_dir}/.gitreview"
    if [[ ! -f "${gitreview}" ]];then
        die "No .gitreview config in top of work directory" $err_no_gitreview
    fi

    gerrit_host=$(grep '^host=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_project=$(grep '^project=' "${gitreview}" | cut -d'=' -f2-)
    gerrit_port=${gerrit_host##*:}
    if [[ -z "$gerrit_port" || "$gerrit_port" == "$gerrit_host" ]];then
        gerrit_port="29418"
    fi

    if ! config exist remote.gerrit.url;then
        nonfatal dossh gerrit >/dev/null 2>&1
        if [[ "$?" -eq 0 ]];then
            debug "Connected to ${gerrit_username}@${gerrit_host}:${gerrit_port} successfully"
            gerrit_url="ssh://${gerrit_username}@${gerrit_host}:${gerrit_port}/${gerrit_project}.git"
        else
            die "SSH connection to ${gerrit_username}@${gerrit_host}:${gerrit_port} failed" $err_ssh_failed
        fi

        stderr "Adding a remote named \"gerrit\" pointing to \"$gerrit_url\"..."
        git remote add gerrit "${gerrit_url}"
    else
        gerrit_url=$(config get remote.gerrit.url | sed "s#/${gerrit_project}.*##;s#.*://##")
        debug "$me: Gerrit instance: \"$gerrit_url\""
    fi
    if [[ ! -f "${git_dir}/hooks/commit-msg" ]];then
        debug "$me: getting commit-msg hook for Change-Id lines from \"${gerrit_url}\"..."
        if ! scp -p -P  "${gerrit_port}" "${gerrit_username}@${gerrit_host}":hooks/commit-msg\
                        "${git_dir}/hooks/commit-msg" >/dev/null 2>&1;then
            die "Failed to \`scp\` the Change-Id hook" $err_scp_failed
        fi
    fi
}

page() {
    local stdin=$(</dev/stdin)
    if [[ ! -z "$stdin" && -z "$@" ]];then
        echo "$stdin" | ${GIT_PAGER:-${PAGER:-cat}}
    elif [[ ! -z "$@" ]];then
        ${GIT_PAGER:-${PAGER:-cat}} "$@"
    fi
}

# gerrit operations
gerrit() {
    dossh gerrit "$@"
}

query_patches() {
    local query="$@"
    debug "$me: querying ${gerrit_url} for patches matching \"${query}\""
    local json=$(gerrit query --format=JSON "${query}" | tr -d '\t')

    # gerrit always provides more than one line of output, unless there
    # were no query results. so, 1 line = no results
    if [[ $(echo "${json}" | wc -l) -eq 1 ]];then
        die "No results for query \"${query}\"" $err_no_results
    fi

    # let me explain this a little bit:
    # first, we take the json, read it line by line, since gerrit sends a
    # single line of json per change matching the query.
    # then, we use jshon to read the line's number, branch, id, name set
    # inside of the owner object, and then the top level subject of the change.
    # after that's done, we use paste to correctly sequence the lines so
    # that we can just parse it easily with cut.
    #
    # also, jshon doesn't seem to properly decode unicode things! but, it
    # does leave us a u#### string. so, we can try and assume it's a unicode
    # symbol which we need to decode... which is really hacky and needs to
    # be fixed in jshon, probably.
    # num|project|branch|changeid|ownername|subject
    local parsed=$(
        echo "$json" | \
            while read line;do
                echo "$line" | \
                    jshon -Q    -e number -up           \
                                -e project -up          \
                                -e branch -up           \
                                -e id     -up           \
                                -e owner -e name -upp   \
                                -e subject -u           |
                    paste -s -d '|||||\n' | grep -v '^$'
            done | sed 's#u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]#\\&#g'
    )
    echo -e "${parsed[@]}"
}

list_patches() {
    query_patches "$@" | while read line; do
        number=$(   echo "$line" | cut -d'|' -f1)
        project=$(  echo "$line" | cut -d'|' -f2)
        branch=$(   echo "$line" | cut -d'|' -f3)
        change=$(   echo "$line" | cut -d'|' -f4)
        owner=$(    echo "$line" | cut -d'|' -f5)
        subject=$(  echo "$line" | cut -d'|' -f6-)
        echo -e "${number}\t${project}:${branch}\t${subject}\t${owner}"
    done | sort -n | column -t -s $'\t' -o $'\t'
}

review() {
    local change
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    local branch=${current_branch}
    local topic
    local type=review
    for arg in "$@";do
        case "$arg" in
            "type:"*)
                local type=${arg#type:}
            ;;
            "branch:"*)
                local branch=${arg#branch:}
            ;;
            "topic:"*)
                local topic="%topic=${arg#topic:}"
            ;;
            *)
                # default is topic
                local topic="%topic=${arg}"
            ;;
        esac
    done
    debug "$me: Making sure you have the Change-Id on commits for Gerrit..."
    for change in $(git rev-list origin/${branch}..${current_branch});do
        if [[ -z $(git show -s --format=%B "${change}" | grep '^Change-Id: ') ]];then
            change=${change:0:7} # rebase uses short hashes
            debug "$me: Amending ${change} with Change-Id hook"
            OLD_EDITOR="${EDITOR}"
            git stash >/dev/null 2>&1
            export EDITOR="sed -i \"s/^pick ${change} /reword ${change} /\""
            git rebase -i "${change}"^
            git stash pop >/dev/null 2>&1
            export EDITOR="${OLD_EDITOR}"
        fi
    done
    case "$type" in
        review)
            local push="HEAD:refs/for/${branch}${topic}"
        ;;
        draft)
            local push="HEAD:refs/drafts/${branch}${topic}"
        ;;
        *)
            die "Invalid review type: ${type}" $err_invalid_review
        ;;
    esac
    git push gerrit "${push}"
}

get_patches() {
    if [[ "$#" -lt 1 ]];then
        stderr "usage: $name get <patches>"
        die $err_args
    fi

    local patches=( $(query_patches "project:${gerrit_project}" | cut -d'|' -f1) )
    echo "${patches[@]}"
    for patch in $@;do
        debug "$me: downloading patch #${patch}"
        if echo -n "${patches[@]}" | tr ' ' '\n' | grep -q "${patch}";then
            die "patch #${patch} does not exist on the Gerrit instance" $err_patch_nonexistent
        else
            debug "$me: patch #${patch} exists on Gerrit"
        fi
        #git pull $(debug && echo -v) gerrit re
    done
}

# vars, shopts, etc
me="git-gerrit"
name=${me/-/ }

# error codes - don't set any of these 0 or 1, dummy
err_not_git_dir=2
err_bare_repo=3
err_no_gitreview=4
err_no_username=5
err_ssh_failed=6
err_scp_failed=7
err_args=8
err_patch_nonexistent=9
err_no_results=10
err_invalid_review=11
err_prog_not_installed=70

# make sure that the programs we need are there
type -fPp git >/dev/null 2>&1 || die "\`git\` isn't installed!" $err_prog_not_installed
type -fPp jshon >/dev/null 2>&1 || die "\`jshon\` isn't installed!" $err_prog_not_installed

# sanity checks
if ! git rev-parse --git-dir >/dev/null 2>&1;then
    die "Not a git repository" $err_not_git_dir
fi

if config exist gitreview.username;then
    gerrit_username=$(config get gitreview.username)
else
    die "You need to set a username to use; \`git config gitreview.username <username>\`" $err_no_username
fi

if [[ "$(git rev-parse --is-bare-repository)" == 'true' ]];then
    die "Cowardly refusing to operate on a bare repository" $err_bare_repo
fi

export git_dir=$(realpath $(git rev-parse --git-dir))
export work_dir=$(realpath $(git rev-parse --show-toplevel))

parse_config

#stderr "git gitdir: $git_dir"
#stderr "git workdir: $work_dir"
#stderr "gitreview: $gitreview"
#stderr "gerrit username: $gerrit_username"
#stderr "gerrit host: $gerrit_host"
#stderr "gerrit project: $gerrit_project"
#stderr "gerrit url: $gerrit_url"

case "$1" in
    ls)
        #debug "$me: Listing patches for ${gerrit_project}..."
        shift
        list_patches "project:${gerrit_project} ${@:-status:open}" | page
    ;;
    query)
        shift
        if [[ -z "$@" ]];then
            die "A query is required" $err_args
        fi
        list_patches "$@" | page
    ;;
    review)
        shift
        review "$@"
    ;;
    get)
        shift
        get_patches "$@"
    ;;
    "")
        help
    ;;
esac
